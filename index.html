<!DOCTYPE html>
<html lang="es">
<!-- Kue v0.2 -->

<head>
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8" />
    <title>Kue v0.2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <style>
        :root {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            color-scheme: dark;
            --bg: #05060a;
            --panel: #111827;
            --accent: #8b5cf6;
            /* Violeta chido */
            --accent-glow: rgba(139, 92, 246, 0.4);
            --text: #f3f4f6;
            --muted: #9ca3af;
            --danger: #ef4444;
            --success: #10b981;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- HEADER --- */
        header {
            padding: 12px 16px;
            background: var(--panel);
            border-bottom: 1px solid #1f2937;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            z-index: 20;
        }

        header h1 {
            margin: 0;
            font-size: 0.95rem;
            font-weight: 800;
            letter-spacing: -0.03em;
            background: linear-gradient(to right, #fff, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* --- MAIN LAYOUT --- */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* --- CANVAS WAVEFORM --- */
        .timeline-container {
            background: #0f172a;
            height: 90px;
            /* Un pel√≠n m√°s alto para dedos gordos */
            flex-shrink: 0;
            position: relative;
            border-bottom: 1px solid #1e293b;
            touch-action: none;
            /* Evita que scrollee la p√°gina al tocar aqu√≠ */
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* --- LISTA DE CUES --- */
        .segments-scroller {
            flex: 1;
            overflow-y: auto;
            padding: 0 0 100px 0;
            /* Espacio extra abajo para ver el √∫ltimo item */
            background: var(--bg);
            scroll-behavior: smooth;
        }

        .segment-item {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 12px;
            padding: 14px 16px;
            border-bottom: 1px solid #1f2937;
            align-items: center;
            background: var(--bg);
            transition: all 0.3s ease;
        }

        .segment-item.active {
            background: rgba(139, 92, 246, 0.15);
            border-left: 4px solid var(--accent);
            padding-left: 12px;
            /* Compensar el borde */
        }

        .time-badge {
            font-family: monospace;
            font-size: 0.9rem;
            color: #c4b5fd;
            background: rgba(139, 92, 246, 0.1);
            padding: 6px 8px;
            border-radius: 6px;
            min-width: 55px;
            text-align: center;
        }

        .segment-note input {
            width: 100%;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1rem;
            /* Texto m√°s grande para leer f√°cil */
            padding: 4px 0;
            outline: none;
        }

        .segment-note input::placeholder {
            color: #4b5563;
            font-style: italic;
        }

        .delete-btn {
            background: transparent;
            border: none;
            color: #6b7280;
            padding: 8px 12px;
            font-size: 1.2rem;
        }

        .delete-btn:active {
            color: var(--danger);
        }

        /* --- CONTROLES (STICKY BOTTOM) --- */
        .controls-area {
            background: rgba(11, 15, 25, 0.98);
            border-top: 1px solid #374151;
            padding: 12px 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 30;
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--muted);
            margin-bottom: 4px;
        }

        .time-main {
            font-family: monospace;
            color: #fff;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr 2.5fr;
            /* M√°s espacio al bot√≥n de acci√≥n */
            gap: 12px;
        }

        button {
            border: none;
            border-radius: 14px;
            font-weight: 700;
            font-size: 1rem;
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: white;
            transition: transform 0.1s;
            position: relative;
            overflow: hidden;
        }

        button:active:not(:disabled) {
            transform: scale(0.97);
        }

        button:disabled {
            opacity: 0.4;
            filter: grayscale(1);
        }

        /* Efecto de brillo al tocar */
        button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            opacity: 0;
            transition: opacity 0.1s;
        }

        button:active::after {
            opacity: 1;
        }

        .btn-play {
            background: #334155;
            color: #e2e8f0;
        }

        .btn-mark {
            background: linear-gradient(135deg, #7c3aed, #db2777);
            box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-mark.recording {
            background: linear-gradient(135deg, #dc2626, #991b1b);
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.5);
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.6);
            }

            70% {
                box-shadow: 0 0 0 6px rgba(220, 38, 38, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(220, 38, 38, 0);
            }
        }

        /* --- MINI TOOLBAR --- */
        .mini-tools {
            display: flex;
            justify-content: space-between;
            padding-top: 8px;
            border-top: 1px solid #1f2937;
        }

        .tool-btn {
            background: transparent;
            color: #94a3b8;
            font-size: 0.75rem;
            padding: 8px 12px;
            font-weight: normal;
        }

        /* --- OVERLAYS --- */
        .file-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(5, 6, 10, 0.9);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 30px;
            text-align: center;
            transition: opacity 0.3s;
        }

        .file-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay-card {
            background: #1e293b;
            padding: 24px;
            border-radius: 20px;
            border: 1px solid #334155;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 320px;
        }

        .big-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            display: block;
        }

        .overlay-btn {
            background: var(--accent);
            width: 100%;
            margin-top: 16px;
            position: relative;
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: #374151;
            color: white;
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
    </style>
</head>

<body>

    <header>
        <div style="display: flex; flex-direction: column;">
            <h1>K√∫e</h1>
            <input type="text" id="projectInput" placeholder="Nombre del proyecto..."
                style="background:transparent; border:none; color:#9ca3af; font-size:0.75rem; outline:none; margin-top:2px;">
        </div>
        <!-- Bot√≥n peque√±o para cambiar archivo si ya est√° cargado -->
        <button id="changeFileBtn" class="tool-btn" style="border:1px solid #334155;">üìÅ Cambiar</button>
    </header>

    <main>
        <!-- CANVAS WAVEFORM -->
        <div class="timeline-container">
            <canvas id="waveCanvas"></canvas>
        </div>

        <!-- LISTA -->
        <div class="segments-scroller" id="listContainer">
            <div style="padding: 40px; text-align: center; color: #4b5563; font-size: 0.9rem;">
                <p>1. Carga la rola.<br>2. Dale al Play.<br>3. Dale al bot√≥n Morado para marcar.</p>
            </div>
        </div>

        <!-- OVERLAY DE CARGA / RECARGA -->
        <div class="file-overlay" id="fileOverlay">
            <div class="overlay-card">
                <span class="big-icon">üéµ</span>
                <h3 style="margin:0 0 8px 0; color:white;">Cargar Audio</h3>
                <p id="overlayMsg" style="margin:0 0 16px 0; color:#94a3b8; font-size:0.9rem; line-height:1.4;">
                    Selecciona el archivo para empezar.
                </p>
                <div style="position:relative; overflow:hidden; border-radius:14px;">
                    <button class="overlay-btn">Elegir Archivo</button>
                    <input type="file" id="audioFile" accept="audio/*"
                        style="position:absolute; left:0; top:0; width:100%; height:100%; opacity:0; cursor:pointer;">
                </div>
            </div>
        </div>
    </main>

    <!-- CONTROLES -->
    <div class="controls-area">
        <div class="info-row">
            <span id="fileNameDisplay"
                style="max-width: 60%; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;">---</span>
            <span class="time-main">
                <span id="currTime">00:00</span> / <span id="totalTime">00:00</span>
            </span>
        </div>

        <div class="action-grid">
            <button id="btnPlay" class="btn-play" disabled>‚ñ∂</button>
            <button id="btnMark" class="btn-mark" disabled>‚ö° INICIAR</button>
        </div>

        <div class="mini-tools">
            <button class="tool-btn" id="btnUndo" disabled>‚Ü© Deshacer</button>
            <button class="tool-btn" id="btnClear">üóë Reset</button>
            <button class="tool-btn" id="btnExport" style="color:var(--accent);">‚¨á JSON</button>
        </div>
    </div>

    <div class="toast" id="toast">Mensaje</div>
    <audio id="audioPlayer" style="display:none;"></audio>

    <script>
        // --- REFERENCIAS ---
        const audio = document.getElementById('audioPlayer');
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const fileOverlay = document.getElementById('fileOverlay');
        const overlayMsg = document.getElementById('overlayMsg');
        const fileInput = document.getElementById('audioFile');
        const changeFileBtn = document.getElementById('changeFileBtn');

        const btnPlay = document.getElementById('btnPlay');
        const btnMark = document.getElementById('btnMark');
        const btnUndo = document.getElementById('btnUndo');
        const btnClear = document.getElementById('btnClear');
        const btnExport = document.getElementById('btnExport');

        const listContainer = document.getElementById('listContainer');
        const projectInput = document.getElementById('projectInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const currTimeDisplay = document.getElementById('currTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        const toast = document.getElementById('toast');

        // --- ESTADO ---
        let segments = [];
        let recording = false;
        let lastCutTime = 0;
        let duration = 0;
        let loadedFileName = "";
        let activeSegmentId = null; // Para el auto-scroll

        const LS_KEY = "cuesheet_v3_data";
        const MIN_SEGMENT_DURATION = 0.5; // Medio segundo m√≠nimo para evitar dobles toques

        // --- INICIALIZACI√ìN ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Cargar datos guardados
            const savedData = loadFromStorage();

            if (savedData && savedData.lastAudioName) {
                // Estamos en modo "Recarga"
                overlayMsg.innerHTML = `Parece que estabas trabajando en:<br><strong style="color:#fff">${savedData.lastAudioName}</strong><br>C√°rgala otra vez para seguirle.`;
                loadedFileName = savedData.lastAudioName;
                projectInput.value = savedData.projectName || "";
                segments = savedData.segments || [];
                renderList();
            } else {
                // Modo limpio
                overlayMsg.textContent = "Carga tu MP3 o WAV para empezar.";
            }

            updateUIState();
            loop();
        }

        // --- AUDIO HANDLERS ---
        fileInput.addEventListener('change', handleFileSelect);
        // El bot√≥n de header re-abre el input del overlay, pero trucado
        changeFileBtn.addEventListener('click', () => {
            fileOverlay.classList.remove('hidden');
            overlayMsg.textContent = "¬øCambiar de rola? Se reiniciar√° el audio.";
        });

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Si es un archivo diferente al guardado y tenemos datos, advertir? 
            // (Por simplicidad, asumimos que el usuario sabe lo que hace)

            const url = URL.createObjectURL(file);
            audio.src = url;
            audio.load();

            loadedFileName = file.name;
            fileNameDisplay.textContent = file.name;

            // Ocultar overlay
            fileOverlay.classList.add('hidden');

            audio.onloadedmetadata = () => {
                duration = audio.duration;
                totalTimeDisplay.textContent = fmt(duration);
                updateUIState();
                saveToStorage();
            };

            audio.onended = () => {
                finishRecording(); // Cerrar √∫ltimo bloque autom√°ticamente
                btnPlay.textContent = "‚ñ∂";
                showToast("Fin de la pista");
            };
        }

        // --- PLAYBACK ---
        btnPlay.addEventListener('click', () => {
            if (audio.paused) {
                audio.play();
                btnPlay.textContent = "‚è∏";
                btnPlay.style.background = "#475569";
            } else {
                audio.pause();
                btnPlay.textContent = "‚ñ∂";
                btnPlay.style.background = "";
            }
        });

        // --- MARK / CUE LOGIC (EL N√öCLEO) ---
        btnMark.addEventListener('click', () => {
            const now = audio.currentTime;
            haptic();

            if (!recording) {
                // Empezar
                startRecording(now);
            } else {
                // Cortar
                // PROTECCI√ìN ANTI-REBOTE (Debounce)
                if (now - lastCutTime < MIN_SEGMENT_DURATION) {
                    showToast("¬°Muy r√°pido! Calma ese dedo.");
                    return;
                }
                cutSegment(now);
            }
        });

        function startRecording(startTime) {
            recording = true;
            lastCutTime = startTime;

            btnMark.textContent = "‚úÇ CORTAR";
            btnMark.classList.add('recording');

            if (audio.paused) btnPlay.click(); // Auto-play
        }

        function cutSegment(endTime) {
            const id = Date.now();
            const newSeg = {
                id: id,
                start: lastCutTime,
                end: endTime,
                note: ""
            };

            segments.push(newSeg);
            lastCutTime = endTime; // El final del anterior es el inicio del nuevo

            renderList();
            saveToStorage();
            updateUIState();

            // Scroll inmediato al nuevo (aunque el loop tambi√©n lo hace)
            scrollToItem(id);
        }

        function finishRecording() {
            if (!recording) return;

            // Guardar el √∫ltimo pedazo hasta donde se detuvo
            const now = audio.currentTime;
            if (now - lastCutTime > MIN_SEGMENT_DURATION) {
                cutSegment(now);
            }

            recording = false;
            btnMark.textContent = "‚ö° INICIAR";
            btnMark.classList.remove('recording');
            lastCutTime = 0;
        }

        // --- UNDO ---
        btnUndo.addEventListener('click', () => {
            if (segments.length === 0) return;

            const removed = segments.pop();
            // Si est√°bamos grabando, regresamos el tiempo de corte al inicio del borrado
            if (recording) {
                lastCutTime = removed.start;
                // Opcional: regresar el audio tambi√©n? Mejor no, rompe el flow.
            }

            renderList();
            saveToStorage();
            updateUIState();
            showToast("Deshecho");
        });

        // --- VISUALS LOOP ---
        function loop() {
            requestAnimationFrame(loop);

            if (!audio.duration) return;

            // 1. Pintar Canvas
            drawCanvas();

            // 2. Actualizar Tiempo
            if (!audio.paused) {
                currTimeDisplay.textContent = fmt(audio.currentTime);

                // 3. AUTO-SCROLL INTELIGENTE
                // Detectar en qu√© segmento estamos
                const currentSeg = segments.find(s => audio.currentTime >= s.start && audio.currentTime < s.end);
                if (currentSeg && currentSeg.id !== activeSegmentId) {
                    activeSegmentId = currentSeg.id;
                    highlightActiveSegment(activeSegmentId);
                }
            }
        }

        function drawCanvas() {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            // Fondo base de bloques
            segments.forEach(s => {
                const x = (s.start / duration) * w;
                const bw = ((s.end - s.start) / duration) * w;
                ctx.fillStyle = "rgba(139, 92, 246, 0.2)";
                ctx.fillRect(x, 0, bw, h);
                ctx.strokeStyle = "rgba(139, 92, 246, 0.4)";
                ctx.strokeRect(x, 0, bw, h);
            });

            // Bloque "Grabando" en vivo
            if (recording) {
                const x = (lastCutTime / duration) * w;
                const bw = ((audio.currentTime - lastCutTime) / duration) * w;
                ctx.fillStyle = "rgba(239, 68, 68, 0.25)"; // Rojo
                ctx.fillRect(x, 0, bw, h);
            }

            // Aguja Playhead
            const px = (audio.currentTime / duration) * w;
            ctx.beginPath();
            ctx.moveTo(px, 0);
            ctx.lineTo(px, h);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#f43f5e"; // Rose 500
            ctx.stroke();
        }

        // Interaction Canvas (Scrubbing)
        canvas.addEventListener('pointerdown', (e) => {
            if (!duration) return;
            const rect = canvas.getBoundingClientRect();
            const pct = (e.clientX - rect.left) / rect.width;
            audio.currentTime = pct * duration;
        });

        // --- LISTA & SCROLL ---
        function renderList() {
            if (segments.length === 0) {
                listContainer.innerHTML = `<div style="padding: 40px; text-align: center; color: #4b5563;">Sin segmentos</div>`;
                return;
            }

            // Re-render completo es costoso, en app real usar√≠amos diffing, pero aqu√≠ aguanta.
            // Truco: solo vaciamos si cambi√≥ el length para no perder foco de inputs si fuera el caso,
            // pero aqu√≠ simplificamos.
            listContainer.innerHTML = "";

            segments.forEach((s, idx) => {
                const el = document.createElement('div');
                el.className = 'segment-item';
                el.id = `seg-${s.id}`;

                // Mark active
                if (activeSegmentId === s.id) el.classList.add('active');

                el.innerHTML = `
          <div class="time-badge" onclick="jumpTo(${s.start})">${fmt(s.start)}</div>
          <div class="segment-note">
            <input type="text" placeholder="Nota bloque ${idx + 1}..." value="${s.note}" 
                   oninput="updateNote(${s.id}, this.value)">
          </div>
          <button class="delete-btn" onclick="deleteSeg(${s.id})">‚úï</button>
        `;
                listContainer.appendChild(el);
            });
        }

        function highlightActiveSegment(id) {
            // Remover clase active de todos
            document.querySelectorAll('.segment-item').forEach(el => el.classList.remove('active'));
            const el = document.getElementById(`seg-${id}`);
            if (el) {
                el.classList.add('active');
                scrollToItem(id);
            }
        }

        function scrollToItem(id) {
            const el = document.getElementById(`seg-${id}`);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Funciones globales para HTML inline
        window.jumpTo = (t) => { audio.currentTime = t; if (audio.paused) audio.play(); };
        window.updateNote = (id, val) => {
            const s = segments.find(x => x.id === id);
            if (s) { s.note = val; saveToStorage(); }
        };
        window.deleteSeg = (id) => {
            if (!confirm("¬øBorrar?")) return;
            segments = segments.filter(x => x.id !== id);
            renderList();
            saveToStorage();
            updateUIState();
        };

        // --- UTILS ---
        function updateUIState() {
            const hasAudio = duration > 0;
            btnPlay.disabled = !hasAudio;
            btnMark.disabled = !hasAudio;
            btnUndo.disabled = segments.length === 0;
            btnExport.disabled = segments.length === 0;
        }

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }

        function fmt(s) {
            if (!isFinite(s)) return "00:00";
            const m = Math.floor(s / 60);
            const sc = Math.floor(s % 60);
            return `${m}:${sc.toString().padStart(2, '0')}`;
        }

        function haptic() {
            if (navigator.vibrate) navigator.vibrate(40);
        }

        function showToast(msg) {
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // Storage
        function saveToStorage() {
            const data = {
                projectName: projectInput.value,
                segments: segments,
                lastAudioName: loadedFileName
            };
            localStorage.setItem(LS_KEY, JSON.stringify(data));
        }

        function loadFromStorage() {
            const raw = localStorage.getItem(LS_KEY);
            return raw ? JSON.parse(raw) : null;
        }

        // Buttons toolbar
        btnClear.addEventListener('click', () => {
            if (confirm("¬øEmpezar de cero? Se borrar√° todo.")) {
                localStorage.removeItem(LS_KEY);
                location.reload();
            }
        });

        btnExport.addEventListener('click', () => {
            const data = {
                project: projectInput.value || "Proyecto",
                exportedAt: new Date().toISOString(),
                segments: segments
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `cues_${Date.now()}.json`;
            a.click();
        });

        // Init
        init();
    </script>
</body>

</html>