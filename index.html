<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />
    <title>Kue Studio V7</title>
    <link rel="manifest" href="manifest.json">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#111827">
    <link rel="apple-touch-icon" href="icon-192.png">

    <style>
        :root {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            color-scheme: dark;
            --bg: #05060a;
            --panel: #111827;
            --accent: #8b5cf6;
            --accent-hover: #7c3aed;
            --text: #f3f4f6;
            --muted: #9ca3af;
            --danger: #ef4444;
            --card-bg: #1f2937;
            --glass: rgba(17, 24, 39, 0.98);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- VISTAS --- */
        .view {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: var(--bg);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s;
            z-index: 10;
        }

        /* --- EDITOR LAYOUT UPGRADE --- */
        .timeline-wrapper {
            height: 140px;
            background: #0f172a;
            position: relative;
            overflow-x: auto;
            /* Enable Horizontal Scroll */
            overflow-y: hidden;
            display: flex;
            align-items: flex-start;
            border-bottom: 1px solid #1e293b;
        }

        /* The invisible spacer that creates the scroll width */
        #timelineSpacer {
            height: 1px;
            flex-shrink: 0;
            opacity: 0;
        }

        /* The canvas sticks to the view */
        canvas#waveCanvas {
            position: sticky;
            left: 0;
            top: 0;
            height: 100%;
            width: 100%;
            /* Dynamically resized by JS to match viewport, but sticky */
            display: block;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #f472b6;
            z-index: 5;
            pointer-events: none;
            will-change: transform;
        }

        .bpm-tag {
            font-family: monospace;
            font-size: 0.8rem;
            color: #fbbf24;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* NOTES MODAL */
        .notes-area {
            width: 100%;
            height: 150px;
            background: #111827;
            border: 1px solid #374151;
            color: #fff;
            padding: 12px;
            border-radius: 8px;
            font-family: sans-serif;
            resize: none;
            font-size: 1rem;
        }

        /* MEDIA PIP */
        .media-pip {
            position: fixed;
            top: 60px;
            right: 16px;
            width: 180px;
            aspect-ratio: 16/9;
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
            z-index: 80;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
        }

        .media-pip.hidden {
            transform: translateX(200%);
            display: none;
        }

        .close-pip {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            cursor: pointer;
        }

        .view.hidden-left {
            transform: translateX(-30%);
            opacity: 0;
            pointer-events: none;
        }

        /* --- HEADER --- */
        header {
            padding: 8px 16px;
            background: var(--panel);
            border-bottom: 1px solid #374151;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 60px;
            flex-shrink: 0;
            z-index: 20;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            background: linear-gradient(to right, #fff, #a78bfa);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* --- HOME --- */
        .project-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 16px;
            align-content: start;
        }

        .project-card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            aspect-ratio: 1 / 1;
            border: 1px solid #374151;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .project-card:active {
            transform: scale(0.96);
        }

        .project-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--accent);
            opacity: 0.7;
        }

        .p-title {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 6px;
            line-height: 1.3;
            color: #fff;
            overflow: hidden;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .p-date {
            font-size: 0.75rem;
            color: var(--muted);
            margin-bottom: 4px;
        }

        .p-count {
            font-size: 0.75rem;
            background: rgba(139, 92, 246, 0.15);
            color: #ddd6fe;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
        }

        .btn-fab {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), #ec4899);
            color: white;
            border: none;
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
            font-size: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 50;
            transition: transform 0.2s;
        }

        .btn-fab:active {
            transform: scale(0.9) rotate(90deg);
        }

        .empty-state {
            grid-column: 1 / -1;
            text-align: center;
            color: var(--muted);
            padding-top: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .empty-icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        /* --- EDITOR --- */
        /* El Canvas ahora es m√°s prominente */
        .timeline-container {
            height: 140px;
            /* M√°s espacio visual */
            background: #0f172a;
            flex-shrink: 0;
            position: relative;
            border-bottom: 1px solid #1e293b;
            touch-action: none;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .bpm-display {
            position: absolute;
            top: 8px;
            right: 8px;
            font-family: monospace;
            font-size: 0.75rem;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            color: #fbbf24;
            padding: 4px 8px;
            border-radius: 6px;
            pointer-events: none;
        }

        .wave-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8rem;
            color: var(--accent);
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 12px;
            border-radius: 12px;
            pointer-events: none;
            display: none;
        }

        .wave-loading.show {
            display: block;
        }

        .segments-scroller {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 200px;
            scroll-behavior: smooth;
        }

        .segment-item {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 12px;
            padding: 16px 16px;
            border-bottom: 1px solid #1f2937;
            align-items: center;
            transition: background 0.2s;
        }

        .segment-item.active {
            background: rgba(139, 92, 246, 0.1);
            border-left: 4px solid var(--accent);
            padding-left: 12px;
        }

        .time-badge {
            font-family: monospace;
            font-size: 0.9rem;
            color: #c4b5fd;
            background: rgba(139, 92, 246, 0.15);
            padding: 6px 10px;
            border-radius: 8px;
            min-width: 60px;
            text-align: center;
            font-weight: bold;
        }

        .segment-note input {
            width: 100%;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 1.05rem;
            padding: 4px 0;
            outline: none;
        }

        .segment-note input::placeholder {
            color: #4b5563;
            font-style: italic;
        }

        .delete-btn {
            background: transparent;
            border: none;
            color: #6b7280;
            font-size: 1.3rem;
            padding: 10px;
            border-radius: 8px;
        }

        /* --- CONTROLES --- */
        .controls-area {
            background: var(--glass);
            backdrop-filter: blur(12px);
            border-top: 1px solid #374151;
            padding: 12px 16px 24px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 30;
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.6);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: #9ca3af;
            margin-bottom: 2px;
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr 2.2fr;
            gap: 12px;
        }

        .main-btn {
            border: none;
            border-radius: 16px;
            font-weight: 700;
            font-size: 1.1rem;
            padding: 18px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: transform 0.1s, filter 0.2s;
            position: relative;
            overflow: hidden;
        }

        .main-btn:active:not(:disabled) {
            transform: scale(0.96);
        }

        .main-btn:disabled {
            opacity: 0.5;
            filter: grayscale(1);
        }

        .btn-play {
            background: #334155;
            color: #f1f5f9;
        }

        .btn-mark {
            background: linear-gradient(135deg, #7c3aed, #db2777);
            box-shadow: 0 6px 20px rgba(124, 58, 237, 0.3);
            font-size: 1.2rem;
            letter-spacing: 1px;
        }

        /* Bot√≥n cuando estamos grabando activo */
        .btn-mark.recording {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            animation: pulse 2s infinite;
        }

        /* Bot√≥n cuando estamos pausados pero en medio de un corte (CONTINUAR) */
        .btn-mark.resume {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            /* Ambar/Naranja */
        }

        .toolbar-row {
            display: flex;
            gap: 12px;
            margin-top: 4px;
        }

        .tool-btn {
            flex: 1;
            background: transparent;
            border: 1px solid #374151;
            color: #9ca3af;
            padding: 10px;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .tool-btn:active {
            background: #1f2937;
            color: #fff;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.6);
            }

            70% {
                box-shadow: 0 0 0 8px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* --- MODALS --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-card {
            background: var(--card-bg);
            padding: 24px;
            border-radius: 20px;
            width: 85%;
            max-width: 340px;
            border: 1px solid #4b5563;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            margin-top: 16px;
        }

        .file-input-btn {
            width: 100%;
            background: var(--accent);
            border: none;
            padding: 14px;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .file-input-real {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 130px;
            /* Arriba de controles */
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: #10b981;
            color: #064e3b;
            padding: 8px 16px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .icon-btn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.3rem;
            padding: 8px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .icon-btn:hover {
            color: #fff;
        }
    </style>
</head>

<body>

    <!-- VISTA: HOME -->
    <div id="viewHome" class="view">
        <header>
            <h1>Kue Studio V7</h1>
        </header>

        <div class="project-list" id="projectList">
            <!-- JS inyecta aqu√≠ -->
        </div>

        <button class="btn-fab" id="btnNewProject">
            <span style="margin-top: -4px;">+</span>
        </button>
    </div>

    <!-- VISTA: EDITOR -->
    <div id="viewEditor" class="view hidden">
        <header>
            <div style="display:flex; align-items:center; gap: 4px;">
                <button id="btnBack" class="icon-btn">‚Üê</button>
                <input type="text" id="projectTitleInput" value="Sin T√≠tulo"
                    style="background:transparent; border:none; color:white; font-weight:800; font-size:1.1rem; outline:none; width: 160px;">
            </div>
            <div style="display:flex; gap:8px;">
                <button id="btnExportJSON" class="icon-btn" title="Exportar JSON">‚¨á</button>
            </div>
        </header>

        <div id="timelineSpacer"></div>
    </div>
    <!-- Old lists removed, new lists inserted -->
    </div>

    <!-- LISTA DE CORTES -->
    <div class="segments-scroller" id="listContainer"></div>

    <!-- CONTROLES -->
    <div class="controls-area">
        <div class="info-row">
            <span id="fileNameDisplay" style="max-width: 50%; opacity:0.7;">...</span>
            <span style="font-family:monospace; font-weight:bold; color:#fff;">
                <span id="currTime">00:00</span> / <span id="totalTime">00:00</span>
            </span>
        </div>

        <div class="action-grid">
            <button id="btnPlay" class="main-btn btn-play" disabled>
                <span>‚ñ∂</span>
            </button>
            <button id="btnMark" class="main-btn btn-mark" disabled>
                <span>‚ö° INICIAR</span>
            </button>
        </div>

        <div class="toolbar-row">
            <button id="btnUndo" class="tool-btn">‚Ü© Deshacer</button>
            <button id="btnDeleteProject" class="tool-btn" style="color:#f87171; border-color:rgba(239,68,68,0.3);">üóë
                Borrar</button>
        </div>
    </div>
    </div>

    <!-- MODAL CREAR -->
    <div class="modal" id="newProjectModal">
        <div class="modal-card">
            <h2 style="margin-top:0; font-size:1.3rem;">Nuevo Proyecto</h2>
            <input type="text" id="newProjectName" placeholder="Nombre (Ej. Clip Final)"
                style="width:100%; padding:14px; background:#111827; border:1px solid #374151; color:white; border-radius:12px; margin-bottom:12px; outline:none; font-size:1rem;">
            <div class="file-input-wrapper">
                <button class="file-input-btn">
                    <span>üéµ</span> Seleccionar Audio
                </button>
                <input type="file" id="newAudioFile" class="file-input-real" accept="audio/*">
            </div>
            <button id="btnCloseModal"
                style="margin-top:16px; background:transparent; border:none; color:#9ca3af; width:100%; padding:12px;">Cancelar</button>
        </div>
    </div>

    <!-- TOAST -->
    <div id="toast" class="toast">¬°Guardado!</div>


    <!-- VIDEO / AUDIO PLAYER (PiP) -->
    <div id="mediaContainer" class="media-pip hidden">
        <video id="videoPlayer" playsinline webkit-playsinline></video>
        <button id="btnCloseVideo" class="close-pip">√ó</button>
    </div>

    <!-- MODAL NOTES -->
    <div class="modal" id="notesModal">
        <div class="modal-card">
            <h2>Notas del Corte</h2>
            <div style="font-size:0.8rem; color:#9ca3af; margin-bottom:8px;">Direcci√≥n / Gui√≥n / Ajustes</div>
            <textarea id="noteTextarea" class="notes-area" placeholder="Escribe aqu√≠..."></textarea>
            <div style="display:flex; gap:8px; margin-top:16px;">
                <button id="btnSaveNote" class="main-btn" style="flex:1; padding:12px; font-size:1rem;">Guardar</button>
            </div>
        </div>
    </div>

    <!-- EXPORT MODAL -->
    <div class="modal" id="exportModal">
        <div class="modal-card">
            <h2>Exportar</h2>
            <div style="display:grid; gap:8px; margin-top:16px;">
                <button class="tool-btn" onclick="exportData('json')">üì¶ JSON (Backup)</button>
                <button class="tool-btn" onclick="exportData('csv')">üìÑ CSV (Excel/Sheets)</button>
                <button class="tool-btn" onclick="exportData('edl')">üé¨ EDL (Premiere/DaVinci)</button>
            </div>
            <button id="btnCloseExport"
                style="margin-top:16px; width:100%; padding:12px; background:transparent; border:none; color:#9ca3af;">Cancelar</button>
        </div>
    </div>


    <script>
        // --- CONSTANTS ---
        const DB_NAME = 'KueStudioDB';
        const DB_VERSION = 2; // Incremented for schema updates if needed
        const PEAKS_RESOLUTION = 100; // Peaks per second (visual resolution)

        // --- STATE ---
        let db;
        let currentProject = null;
        let recording = false;
        let activeSegmentStart = null;
        let duration = 0;
        let activeSegmentId = null;
        let lastActiveSegmentId = null;

        // Audio/Video State
        let audioContext = null;
        let sourceNode = null;
        let audioBuffer = null;
        let peaks = []; // Optimized peaks array [min, max, min, max...]
        let isVideo = false;

        // Viewer State
        let zoomLevel = 1; // 1 = 100px per second approx
        let scrollLeft = 0;
        let isScrolling = false;

        // --- UI REFS ---
        const els = {
            views: { home: document.getElementById('viewHome'), editor: document.getElementById('viewEditor') },
            modals: { new: document.getElementById('newProjectModal'), notes: document.getElementById('notesModal'), export: document.getElementById('exportModal') },
            media: { container: document.getElementById('mediaContainer'), player: document.getElementById('videoPlayer') },
            canvas: document.getElementById('waveCanvas'),
            timelineWrapper: document.getElementById('timelineWrapper'),
            timelineSpacer: document.getElementById('timelineSpacer'),
            zoomSlider: document.getElementById('zoomSlider'),
            projectList: document.getElementById('projectList'),
            bpm: document.getElementById('bpmDisplay'),
            loader: document.getElementById('waveLoading'),
            playhead: document.getElementById('playhead'),
            list: document.getElementById('listContainer'),
            title: document.getElementById('projectTitleInput'),
            fileDisplay: document.getElementById('fileNameDisplay'),
            timeCurr: document.getElementById('currTime'),
            timeTotal: document.getElementById('totalTime'),
            textArea: document.getElementById('noteTextarea'),
            btns: {
                play: document.getElementById('btnPlay'),
                mark: document.getElementById('btnMark'),
                export: document.getElementById('btnExportJSON'), // Now opens modal
                new: document.getElementById('btnNewProject'),
                back: document.getElementById('btnBack'),
                delete: document.getElementById('btnDeleteProject'),
                undo: document.getElementById('btnUndo'),
                saveNote: document.getElementById('btnSaveNote'),
                closeExport: document.getElementById('btnCloseExport')
            }
        };

        const ctx = els.canvas.getContext('2d', { alpha: false }); // Opt: No alpha channel needed for background

        // --- DB ---
        const initDB = () => new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = (e) => {
                db = e.target.result;
                if (!db.objectStoreNames.contains('projects')) db.createObjectStore('projects', { keyPath: 'id' });
            };
            req.onsuccess = (e) => { db = e.target.result; resolve(db); };
            req.onerror = (e) => reject(e);
        });

        const dbOps = {
            save: (p) => new Promise((res, rej) => {
                const tx = db.transaction('projects', 'readwrite');
                tx.objectStore('projects').put(p);
                tx.oncomplete = () => res(); tx.onerror = () => rej(tx.error);
            }),
            getAll: () => new Promise((res, rej) => {
                const tx = db.transaction('projects', 'readonly');
                const req = tx.objectStore('projects').getAll();
                req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error);
            }),
            get: (id) => new Promise((res, rej) => {
                const tx = db.transaction('projects', 'readonly');
                const req = tx.objectStore('projects').get(id);
                req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error);
            }),
            delete: (id) => new Promise((res, rej) => {
                const tx = db.transaction('projects', 'readwrite');
                tx.objectStore('projects').delete(id);
                tx.oncomplete = () => res(); tx.onerror = () => rej(tx.error);
            })
        };

        // --- INIT & NAV ---
        async function initApp() {
            await initDB();

            // Resize Observer for Canvas
            const resizeObserver = new ResizeObserver(() => resizeCanvas());
            resizeObserver.observe(els.timelineWrapper);

            // Scroll Listener
            els.timelineWrapper.addEventListener('scroll', () => {
                scrollLeft = els.timelineWrapper.scrollLeft;
                if (!els.media.player.paused && !isScrolling) {
                    // Optimized: Don't force redraw on scroll if playing (loop handles it)
                } else {
                    drawWaveform(); // Manual scroll needs redraw
                }
            }, { passive: true });

            loadHome();
            loop();
        }

        async function loadHome() {
            els.media.player.pause();
            els.media.player.src = "";
            els.media.container.classList.add('hidden');

            currentProject = null;
            recording = false;
            activeSegmentStart = null;
            audioBuffer = null;
            peaks = [];

            els.views.home.classList.remove('hidden-left');
            els.views.editor.classList.add('hidden');
            renderProjectList();
        }

        async function renderProjectList() {
            els.projectList.innerHTML = '<div style="color:var(--muted); text-align:center; padding:20px;">Cargando...</div>';
            const projects = await dbOps.getAll();
            els.projectList.innerHTML = '';

            if (projects.length === 0) {
                els.projectList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üíø</div>
                        <div><h3 style="margin:0;">Sin Proyectos</h3><p style="font-size:0.9rem;">Importa audio o video para empezar.</p></div>
                    </div>`;
            } else {
                projects.sort((a, b) => b.createdAt - a.createdAt).forEach(p => {
                    const card = document.createElement('div');
                    card.className = 'project-card';
                    card.innerHTML = `
                        <div><div class="p-title">${p.name}</div><div class="p-date">${new Date(p.createdAt).toLocaleDateString()}</div></div>
                        <div class="p-meta"><span class="p-count">${p.segments.length} cortes</span></div>`;
                    card.onclick = () => openProject(p.id);
                    els.projectList.appendChild(card);
                });
            }
        }

        async function openProject(id) {
            const p = await dbOps.get(id);
            if (!p) return;
            currentProject = p;

            // Load Media
            const url = URL.createObjectURL(p.audioBlob);
            els.media.player.src = url;

            // Video check
            isVideo = p.audioBlob.type.startsWith('video');
            if (isVideo) {
                els.media.container.classList.remove('hidden');
            } else {
                els.media.container.classList.add('hidden');
            }

            els.title.value = p.name;
            els.fileDisplay.textContent = p.audioBlob.name;

            // Reset State
            recording = false;
            activeSegmentStart = null;
            updateMarkButtonUI();

            // Zoom Reset
            zoomLevel = 1;
            els.zoomSlider.value = 1;

            els.views.home.classList.add('hidden-left');
            els.views.editor.classList.remove('hidden');

            // BPM
            els.bpm.textContent = p.bpm ? p.bpm + " BPM" : "-- BPM";

            // Wait for metadata
            els.media.player.onloadedmetadata = () => {
                duration = els.media.player.duration;
                els.timeTotal.textContent = fmt(duration);
                updateSpacerWidth();
                renderSegments();
                updateControls();

                // Analyze
                analyzeAudio(p.audioBlob);
            };

            els.media.player.onended = () => {
                els.btns.play.innerHTML = "<span>‚ñ∂</span>";
                els.btns.play.style.background = "";
            };
        }

        // --- CORE LOGIC: ANALYSIS (OPTIMIZED) ---
        async function analyzeAudio(blob) {
            try {
                els.loader.classList.add('show');
                els.loader.textContent = "Procesando...";

                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Decode Full ArrayBuffer - Heavy op, but necessary for clean waveform
                // TODO: For >50MB files, we should use a different strategy, but for now this is standard PWA limit.
                const arrayBuffer = await blob.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // 1. Generate Waveform (Async / Chunked)
                await generateWaveformChunked(audioBuffer);

                // 2. Detect BPM (Optimized)
                if (!currentProject.bpm) {
                    detectBPM(audioBuffer);
                }

                els.loader.classList.remove('show');
            } catch (e) {
                console.error(e);
                els.loader.textContent = "Error decode";
            }
        }

        function generateWaveformChunked(buffer) {
            return new Promise((resolve) => {
                const data = buffer.getChannelData(0);
                const totalPeaks = Math.ceil(buffer.duration * PEAKS_RESOLUTION);
                const step = Math.floor(data.length / totalPeaks);
                peaks = new Float32Array(totalPeaks * 2); // [min, max, min, max...]

                let i = 0;
                const chunkSize = 5000; // Process 5000 peaks per frame

                function process() {
                    const end = Math.min(i + chunkSize, totalPeaks);
                    for (; i < end; i++) {
                        let min = 1.0, max = -1.0;
                        const startSample = i * step;
                        // Downsample the step
                        for (let j = 0; j < step; j += 10) { // Skip samples for speed (lossy)
                            const val = data[startSample + j];
                            if (val < min) min = val;
                            if (val > max) max = val;
                        }
                        // Simple noise gate
                        if (min > -0.01) min = -0.01;
                        if (max < 0.01) max = 0.01;

                        peaks[i * 2] = min;
                        peaks[i * 2 + 1] = max;
                    }

                    if (i < totalPeaks) {
                        // Draw partial result (progressive loading)
                        drawWaveform();
                        requestAnimationFrame(process);
                    } else {
                        drawWaveform();
                        resolve();
                    }
                }
                process();
            });
        }

        async function detectBPM(buffer) {
            try {
                // Offline Context for filtering
                const offlineCtx = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;

                // Lowpass Filter (Isolate Kick/Bass)
                const filter = offlineCtx.createBiquadFilter();
                filter.type = "lowpass";
                filter.frequency.value = 150;

                source.connect(filter);
                filter.connect(offlineCtx.destination);
                source.start(0);

                const renderedBuffer = await offlineCtx.startRendering();
                const data = renderedBuffer.getChannelData(0);

                // Peak detection on filtered data
                const sampleRate = buffer.sampleRate;
                const threshold = 0.25;
                let hits = [];

                // Analyze center 30s
                const center = Math.floor(data.length / 2);
                const range = sampleRate * 15;
                const start = Math.max(0, center - range);
                const end = Math.min(data.length, center + range);

                for (let i = start; i < end; i++) {
                    if (data[i] > threshold) {
                        if (hits.length === 0 || (i - hits[hits.length - 1]) > (sampleRate * 0.3)) { // 0.3s debounce (Limit 200BPM)
                            hits.push(i);
                        }
                    }
                }

                if (hits.length > 5) {
                    let intervals = [];
                    for (let i = 0; i < hits.length - 1; i++) {
                        intervals.push(hits[i + 1] - hits[i]);
                    }
                    // Sort intervals and take median
                    intervals.sort((a, b) => a - b);
                    const medianDist = intervals[Math.floor(intervals.length / 2)];

                    let bpm = 60 / (medianDist / sampleRate);
                    // Normalize (70-170)
                    while (bpm < 70) bpm *= 2;
                    while (bpm > 170) bpm /= 2;

                    bpm = Math.round(bpm);
                    currentProject.bpm = bpm;
                    els.bpm.textContent = bpm + " BPM";
                    saveCurrentState();
                }
            } catch (e) { console.error("BPM Fail", e); }
        }

        // --- RENDER LOOP ---
        function resizeCanvas() {
            // Internal canvas matches viewport width for performance
            // We draw only the visible slice
            if (els.timelineWrapper.clientWidth) {
                els.canvas.width = els.timelineWrapper.clientWidth;
                els.canvas.height = els.timelineWrapper.clientHeight;
                drawWaveform();
            }
        }

        function updateSpacerWidth() {
            // Width = (Duration * Resolution) * ZoomFactor / Resolution ... 
            // Simplified: Base width = Duration * 50px? 
            // Let's say zoom 1 = 20px per second. Max zoom = 200px/s?
            const pxPerSec = 20 * zoomLevel;
            const totalW = duration * pxPerSec;
            els.timelineSpacer.style.width = `${totalW}px`;

            // Keep playhead visual sync
            requestAnimationFrame(drawWaveform);
        }

        els.zoomSlider.oninput = (e) => {
            zoomLevel = parseFloat(e.target.value);
            updateSpacerWidth();
        };

        function drawWaveform() {
            const cvsW = els.canvas.width;
            const cvsH = els.canvas.height;
            ctx.clearRect(0, 0, cvsW, cvsH);
            ctx.fillStyle = "#111827";
            ctx.fillRect(0, 0, cvsW, cvsH); // BG

            if (!peaks.length) return;

            // Coordinate System
            // spacerWidth = duration * 20 * zoomLevel.
            // scrollLeft = viewport start.
            const pxPerSec = 20 * zoomLevel;
            const visibleStartSec = scrollLeft / pxPerSec;
            const visibleEndSec = (scrollLeft + cvsW) / pxPerSec;

            // Map to peaks array
            const peakStartIdx = Math.floor(visibleStartSec * PEAKS_RESOLUTION) * 2;
            const peakEndIdx = Math.ceil(visibleEndSec * PEAKS_RESOLUTION) * 2;

            // Draw Wave
            ctx.fillStyle = "rgba(139, 92, 246, 0.4)";
            ctx.beginPath();

            const startX = - (scrollLeft % 1); // Sub-pixel align? Nah just 0 works relative to viewport
            // Actually, we must offset by `scrollLeft` relative to absolute X.
            // x_screen = x_absolute - scrollLeft.

            const centerY = cvsH / 2;
            const halfH = cvsH / 2.2;

            // Performance: Draw lines
            for (let i = peakStartIdx; i < peakEndIdx; i += 2) {
                if (i >= peaks.length) break;
                if (i < 0) continue;

                const peakTime = (i / 2) / PEAKS_RESOLUTION;
                const x = (peakTime * pxPerSec) - scrollLeft;

                const min = peaks[i];
                const max = peaks[i + 1];

                // Draw a vertical bar (cheaper than path sometimes, but Path is cleaner)
                // For zoom out, bars overlap -> dense visual.
                const w = Math.max(1, (1 / PEAKS_RESOLUTION) * pxPerSec);

                ctx.rect(x, centerY + (min * halfH), w, (max - min) * halfH);
            }
            ctx.fill();

            // Draw Segments
            if (currentProject) {
                currentProject.segments.forEach(s => {
                    const startX = (s.start * pxPerSec) - scrollLeft;
                    const endX = (s.end * pxPerSec) - scrollLeft;

                    if (endX < 0 || startX > cvsW) return; // Cull

                    const w = endX - startX;

                    // Box
                    ctx.fillStyle = "rgba(139, 92, 246, 0.15)";
                    if (activeSegmentId === s.id) ctx.fillStyle = "rgba(139, 92, 246, 0.35)";
                    ctx.fillRect(startX, 0, w, cvsH);

                    // Border
                    ctx.strokeStyle = "rgba(139, 92, 246, 0.5)";
                    ctx.strokeRect(startX, 0, w, cvsH);

                    // Valid Label (if big enough)
                    if (w > 30) {
                        ctx.fillStyle = "#ddd6fe";
                        ctx.font = "10px monospace";
                        ctx.fillText(fmt(s.start), startX + 4, 12);
                    }
                });
            }

            // Draw Recording Ghost
            if (recording && activeSegmentStart !== null) {
                const startX = (activeSegmentStart * pxPerSec) - scrollLeft;
                const endX = (els.media.player.currentTime * pxPerSec) - scrollLeft;
                const w = endX - startX;
                ctx.fillStyle = "rgba(239, 68, 68, 0.2)";
                ctx.fillRect(startX, 0, w, cvsH);
                ctx.strokeStyle = "#ef4444";
                ctx.strokeRect(startX, 0, w, cvsH);
            }
        }

        function loop() {
            requestAnimationFrame(loop);

            if (!currentProject || !duration) return;

            const pxPerSec = 20 * zoomLevel;
            const currentTime = els.media.player.currentTime;

            // 1. Update Playhead Position
            // The Playhead is a separate DOM element for smoothness, OR drawn on Canvas.
            // Using DOM element in `timelineWrapper` is trickier because it needs absolute pos.
            // Let's just draw it OR move a sticky div? 
            // In the HTML I put `<div id="playhead">`. Let's move it.
            const playheadX = (currentTime * pxPerSec);
            els.playhead.style.transform = `translateX(${playheadX}px)`;

            // 2. Auto Scroll (Follow Playhead)
            if (!els.media.player.paused) {
                const visibleW = els.timelineWrapper.clientWidth;
                // If playhead goes near end of view, scroll.
                if (playheadX > scrollLeft + visibleW * 0.8) {
                    els.timelineWrapper.scrollLeft += visibleW * 0.5; // Jump scroll (Pager)
                }
                // Draw dynamic ghost segment
                if (recording) drawWaveform();
            }

            // 3. UI Time
            els.timeCurr.textContent = fmt(currentTime);

            // 4. Highlight Logic (Debounced Scroll)
            if (!els.media.player.paused) {
                const active = currentProject.segments.find(s => currentTime >= s.start && currentTime < s.end);
                const activeId = active ? active.id : null;

                if (activeSegmentId !== activeId) {
                    activeSegmentId = activeId;

                    // DOM Updates
                    document.querySelectorAll('.segment-item').forEach(el => el.classList.remove('active'));
                    if (activeId) {
                        const el = document.getElementById(`seg-${activeId}`);
                        if (el) {
                            el.classList.add('active');
                            // Only auto-scroll the list if we really changed segments
                            if (activeId !== lastActiveSegmentId) {
                                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                lastActiveSegmentId = activeId;
                            }
                        }
                    }
                }
            }
        }

        // --- CONTROLS ---
        els.btns.play.onclick = () => {
            if (els.media.player.paused) {
                els.media.player.play();
                els.btns.play.innerHTML = "<span>‚è∏</span>";
                els.btns.play.style.background = "#475569";
            } else {
                els.media.player.pause();
                els.btns.play.innerHTML = "<span>‚ñ∂</span>";
                els.btns.play.style.background = "";
            }
        };

        els.btns.mark.onclick = () => {
            if (!currentProject) return;
            const now = els.media.player.currentTime;
            if (navigator.vibrate) navigator.vibrate(40);

            if (!recording) {
                startSegment(now);
                if (els.media.player.paused) els.media.player.play();
            } else {
                if (now - activeSegmentStart < 0.1) return;
                finishSegment(now);
                startSegment(now); // Chain mode
            }
        };

        function startSegment(startTime) {
            recording = true;
            activeSegmentStart = startTime;
            updateMarkButtonUI();
        }

        function finishSegment(endTime) {
            const newSeg = {
                id: Date.now(),
                start: activeSegmentStart,
                end: endTime,
                note: ""
            };
            currentProject.segments.push(newSeg);
            activeSegmentStart = endTime;
            renderSegments();
            saveCurrentState();

            // Scroll list
            setTimeout(() => {
                const el = document.getElementById(`seg-${newSeg.id}`);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 50);

            drawWaveform();
        }

        function updateMarkButtonUI() {
            const btn = els.btns.mark;
            if (recording) {
                btn.innerHTML = "<span>‚úÇ CORTAR</span>";
                btn.className = "main-btn btn-mark recording";
                if (els.media.player.paused) {
                    btn.innerHTML = "<span>‚ñ∂ CONTINUAR</span>";
                    btn.className = "main-btn btn-mark resume";
                }
            } else {
                btn.innerHTML = "<span>‚ö° INICIAR</span>";
                btn.className = "main-btn btn-mark";
            }
        }

        els.media.player.onpause = updateMarkButtonUI;
        els.media.player.onplay = updateMarkButtonUI;

        // --- SEGMENT LIST & MODAL UI ---
        function renderSegments() {
            els.list.innerHTML = "";
            if (!currentProject || currentProject.segments.length === 0) {
                els.list.innerHTML = `<div style="padding:40px; text-align:center; color:#4b5563;">A√∫n no hay cortes.</div>`;
                return;
            }
            currentProject.segments.sort((a, b) => a.start - b.start);

            currentProject.segments.forEach((s, idx) => {
                const el = document.createElement('div');
                el.className = 'segment-item';
                if (activeSegmentId === s.id) el.classList.add('active');
                el.id = `seg-${s.id}`;

                const noteShort = s.note ? s.note.substring(0, 20) + (s.note.length > 20 ? "..." : "") : "";
                const noteBtnClass = s.note ? "tool-btn" : "tool-btn";
                const noteIcon = s.note ? "üìù" : "‚ûï";

                el.innerHTML = `
                  <div class="time-badge" onclick="jumpTo(${s.start})">${fmt(s.start)}</div>
                  <div style="flex:1; display:flex; gap:8px; align-items:center;">
                      <button class="${noteBtnClass}" style="padding:4px 8px; font-size:0.8rem;" onclick="openNoteModal(${s.id})">
                        ${noteIcon} <span style="opacity:0.7; font-weight:normal;">${noteShort || "Nota"}</span>
                      </button>
                  </div>
                  <button class="delete-btn" onclick="deleteSeg(${s.id})">‚úï</button>`;
                els.list.appendChild(el);
            });
            drawWaveform(); // Update highlights
        }

        // --- NOTES MODAL LOGICState ---
        let editingSegmentId = null;
        window.openNoteModal = (segId) => {
            editingSegmentId = segId;
            const seg = currentProject.segments.find(s => s.id === segId);
            if (seg) {
                els.textArea.value = seg.note || "";
                els.modals.notes.classList.add('show');
                els.textArea.focus();
            }
        };

        els.btns.saveNote.onclick = () => {
            if (editingSegmentId) {
                const seg = currentProject.segments.find(s => s.id === editingSegmentId);
                if (seg) {
                    seg.note = els.textArea.value;
                    saveCurrentState();
                    renderSegments();
                }
            }
            els.modals.notes.classList.remove('show');
        };

        els.modals.notes.onclick = (e) => {
            if (e.target === els.modals.notes) els.modals.notes.classList.remove('show');
        };

        // --- EXPORT LOGIC ---
        els.btns.export.onclick = () => els.modals.export.classList.add('show');
        els.btns.closeExport.onclick = () => els.modals.export.classList.remove('show');

        window.exportData = (format) => {
            if (!currentProject) return;
            const p = currentProject;
            let content = "";
            let mime = "text/plain";
            let ext = "txt";

            if (format === 'json') {
                content = JSON.stringify({ name: p.name, bpm: p.bpm, segments: p.segments }, null, 2);
                mime = "application/json"; ext = "json";
            }
            else if (format === 'csv') {
                content = "Index,Start,End,Duration,Note\n";
                p.segments.forEach((s, i) => {
                    content += `${i + 1},${fmt(s.start)},${fmt(s.end)},${(s.end - s.start).toFixed(2)},"${(s.note || "").replace(/"/g, '""')}"\n`;
                });
                mime = "text/csv"; ext = "csv";
            }
            else if (format === 'edl') {
                // Basic CMX 3600 approximation
                content = `TITLE: ${p.name}\nFCM: NON-DROP FRAME\n\n`;
                p.segments.forEach((s, i) => {
                    // 001  AX       V     C        00:00:00:00 00:00:05:00 00:00:00:00 00:00:05:00 
                    // Timecode calc is complex without fps, assuming 30fps roughly for demo
                    const toTC = (sec) => {
                        const f = Math.floor((sec % 1) * 30);
                        const sc = Math.floor(sec % 60);
                        const m = Math.floor(sec / 60) % 60;
                        const h = Math.floor(sec / 3600);
                        return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sc.toString().padStart(2, '0')}:${f.toString().padStart(2, '0')}`;
                    };
                    const line = `${(i + 1).toString().padStart(3, '0')}  AX       V     C        ${toTC(s.start)} ${toTC(s.end)} ${toTC(s.start)} ${toTC(s.end)}\n`;
                    content += line;
                    if (s.note) content += `* COMMENT: ${s.note}\n`;
                });
                ext = "edl";
            }

            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([content], { type: mime }));
            a.download = `${p.name}_export.${ext}`;
            a.click();
            els.toast.textContent = "Exportado " + ext.toUpperCase();
            els.toast.classList.add('show');
            setTimeout(() => els.toast.classList.remove('show'), 2000);
            els.modals.export.classList.remove('show');
        };

        // --- GLOBAL HELPERS ---
        window.jumpTo = (t) => { els.media.player.currentTime = t; if (els.media.player.paused) els.media.player.play(); };
        window.deleteSeg = (id) => { if (confirm("¬øBorrar?")) { currentProject.segments = currentProject.segments.filter(x => x.id !== id); renderSegments(); saveCurrentState(); } };
        async function saveCurrentState() { if (currentProject) await dbOps.save(currentProject); }
        function fmt(s) { if (!isFinite(s)) return "00:00"; const m = Math.floor(s / 60), sc = Math.floor(s % 60); return `${m}:${sc.toString().padStart(2, '0')}`; }
        function updateControls() { const on = duration > 0; els.btns.play.disabled = !on; els.btns.mark.disabled = !on; }

        // --- BOOT ---
        // Setup Media Inputs
        document.getElementById('newAudioFile').setAttribute('accept', 'audio/*,video/*');
        document.getElementById('newAudioFile').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const name = document.getElementById('newProjectName').value.trim() || file.name.split('.')[0];
            const id = Date.now().toString();
            await dbOps.save({ id, name, createdAt: Date.now(), audioBlob: file, segments: [] });
            els.modals.new.classList.remove('show');
            openProject(id);
        };

        // Utilities
        els.btns.new.onclick = () => els.modals.new.classList.add('show');
        els.modals.new.querySelector('#btnCloseModal').onclick = () => els.modals.new.classList.remove('show');
        els.btns.back.onclick = () => { saveCurrentState(); loadHome(); };
        els.btns.delete.onclick = async () => { if (confirm("¬øBorrar Proyecto?")) { await dbOps.delete(currentProject.id); loadHome(); } };
        els.btns.undo.onclick = () => {
            if (currentProject?.segments.length > 0) {
                const rem = currentProject.segments.pop();
                if (recording) {
                    activeSegmentStart = rem.start;
                    els.media.player.currentTime = rem.start;
                }
                renderSegments(); saveCurrentState();
            }
        };

        document.getElementById('btnCloseVideo').onclick = () => els.media.container.classList.add('hidden');

        initApp();
    </script>
</body>

</html>